# format string 0
We know that *%s* is used to represent string literals. 
	For this challenge, I downloaded the source file and in order to get an idea, I trial ran the challenge. So, from there I was asked to pick a burger recommendation for a customer and first I was unable to get the hint which was given in the description statement. So, I gave random burger names from the list, which obviously didn't give me the flag. So, now I went through the code.
```
void sigsegv_handler(int sig) {
    printf("\n%s\n", flag);
    fflush(stdout);
    exit(1);
}
```

From here, I was able to understand that what we need to do to get the flag is to make a segmentation error.

Now, I went back to finding the burger which is to be given to move to the next step.
```
 char choice1[BUFSIZE];
    scanf("%s", choice1);
    char *menu1[3] = {"Breakf@st_Burger", "Gr%114d_Cheese", "Bac0n_D3luxe"};
```

```
 int count = printf(choice1);
        if (count > 2 * BUFSIZE) {
            serve_bob();
        } else {
            printf("%s\n%s\n",
                    "Patrick is still hungry!",
                    "Try to serve him something of larger size!");
            fflush(stdout);
```

The 3 burgers shown in the former lines mentioned were the ones which we were supposed to give recommendation. From the later lines shown, we can see that in order to move to next one, we need to give a string that is large in size. If you observe the burger name *Grill%114d_Cheese*, the *%114* means that it will a create a string filled wih 114 spaces. Since that is larger than 2 times the buffer size, i.e 64, first part is completed and we move to the next statement they provide.

```
Good job! Patrick is happy! Now can you serve the second customer?
Sponge Bob wants something outrageous that would break the shop (better be served quick before the shop owner kicks you out!)
Please choose from the following burgers: Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
```

So, from here we can see we need to give something really large in size to the next customer. There was no particular condition given for the recommendation unlike the first customer, so what I basically thought was to find the burger name which can form a segmentation error in the program.
	The burger name `Cla%sic_Che%s%steak` contained  *%s* in it, but we know string literals mentioned should be followed by parameters too. But here, there was no parameters provided for these literals. And when literals exist without their parameters, it causes a segmentation error. 
`ClaCla%sic_Che%s%steakic_Che(null)` This is what is shown to be precise. *NULL Parameter* causes segmentation fault.
	After realizing this, I just gave the specific burger name  and I got the flag.
`Flag: picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_74f6c0e7} `

## References Used:
None


# Buffer overflow 0
I downloaded the file and looked through the lines.
```
void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}
```
So, from this lines, I understood that we would get the flag if we are able to generate a segmentation error in the program.
```
 fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
```

```
printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
```
So, after observing the given lines, I realized that what I was supposed to do was basically cause an buffer overflow. To do this, what I did was just spam something random when they asked me for an input. Since there was a lot of characters, there was an overflow and I got the flag.

```
giridharsreekumar-picoctf@webshell:~$ nc saturn.picoctf.net 63956
Input: avbighughauogaogojgaioghio
picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}
```

` Flag:picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}`

## References Used:
- https://youtu.be/x19LMDmvh6U?si=-loklzSBdoLoq1NV


  # two-sum
I started the challenging by going through the c file they have provided.

<img width="1004" alt="twosum" src="https://github.com/user-attachments/assets/38f8c381-02e8-489a-9fdd-6edf41dd60ed" />


After going through the file, I understood there might be a chance we might get the flag by doing an integer overflow and this was confirmed by looking at the hints of the challenge.
	In order to get -1 as return, I need two positive numbers but their sum to be negative. So, after thinking for a while, I thought I could make this possible by adding the largest no available in the 32 bit file to any no which make the sum negative.
I used `31^1-1` to get the largest no in the file i.e, *2147483647* and added 1 to it to cause the integer overflow and get the flag.

`FLAG:picoCTF{Tw0_Sum_Integer_Bu773R_0v3rfl0w_f6ed8057}`

## References Used:
- https://youtu.be/jyiNM3SKJgY?si=qJIT8RVSOuKv3hfO

